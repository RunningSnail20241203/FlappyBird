# 《天空奇遇：羽翼挑战》系统架构设计

## 1. 整体架构概览

采用**分层架构** + **组件模式**，核心设计模式：

1. **状态模式**：游戏状态管理

2. **观察者模式**：事件系统

3. **MVVM模式**：UI数据绑定

4. **策略模式**：游戏模式切换

5. **单例模式**：管理器类

6. **对象池模式**：性能优化

## 2. 核心系统架构

### 2.1 游戏状态机系统 (State Pattern)

```csharp
/// <summary>
/// 状态接口
/// </summary>
public interface IState
{
    string Name { get; }
    void OnEnter();
    void OnUpdate(float deltaTime);
    void OnFixedUpdate(float fixedDeltaTime);
    void OnExit();
}

/// <summary>
/// 抽象基础状态
/// </summary>
public abstract class StateBase : IState
{
    public virtual string Name  => GetType().Name;
    public virtual void OnEnter() { }
    public virtual void OnUpdate(float deltaTime){}
    public virtual void OnFixedUpdate(float fixedDeltaTime) { }
    public virtual void OnExit(){}
}

// 状态基类
public abstract class GameStateBase : StateBase
{
    private readonly List<CommandBase> _commands = new(); // 指令集合
    protected virtual Dictionary<string, Action<BaseCommandArgs>> CommandHandlers { get; } = new(); // 指令对应的处理函数集合
    public override void OnUpdate(float deltaTime){} // 如果有表现相关的处理放在这里面
    public override void OnFixedUpdate(float fixedDeltaTime){} //在FixedUpdate中处理所有的Command,因为这个FixedUpdate是游戏的逻辑循环，每个FixedUpdate处理当前逻辑帧搜集到的全部的Command
    public override void OnExit(){} // 退出状态机时，清除所有command
    public void AddCommand(CommandBase commandBase){} // 添加Command，状态机内部用Command来处理其他模块的请求
    private void ClearCommands(){} // 清除所有Command
    private void ProcessCommands(){} // 用来处理ViewModel或者其他模块传递过来的Command
    private void QuitGame(){} // 特殊指令的处理，用来处理退出游戏，由于是全局响应的，所以放在基类了，可以考虑优化
}

// 具体状态类
public class MenuState : GameStateBase
{
    public override void Enter() {}
    public override void Exit() {}
    public override void OnUpdate(float deltaTime) {}
    public override void OnFixedUpdate(float fixedDeltaTime) {}
}

public class PlayingState : GameStateBase
{
    public override void Enter() {}
    public override void Exit() {}
    public override void OnUpdate() {}
    public override void OnFixedUpdate(float fixedDeltaTime) {}
}

public class PauseState : GameStateBase 
{ 
    public override void Enter() {}
    public override void Exit() {}
    public override void OnUpdate() {}
    public override void OnFixedUpdate(float fixedDeltaTime) {}
}

public class GameOverState : GameStateBase 
{  
    public override void Enter() {}
    public override void Exit() {}
    public override void OnUpdate() {}
    public override void OnFixedUpdate(float fixedDeltaTime) {}
}

public class SettingState : GameStateBase
{
    public override void Enter() {}
    public override void Exit() {}
    public override void OnUpdate() {}
    public override void OnFixedUpdate(float fixedDeltaTime) {}
}


/// <summary>
/// 状态机接口
/// </summary>
/// <typeparam name="T">状态类型</typeparam>
public interface IStateMachine<T> where T : class, IState
{
    T CurrentState { get; }
    T PreviousState { get; }
    void ChangeState(T newState);
    void ChangeState<TState>() where TState : class, T;
    bool IsInState<TState>() where TState : class, T;
    void OnUpdate(float deltaTime);
    void OnFixedUpdate(float fixedDeltaTime);
}


/// <summary>
/// 泛型状态机
/// </summary>
/// <typeparam name="T">状态类型</typeparam>
public class StateMachine<T> : IStateMachine<T> where T : class, IState
{
    public T CurrentState { get; private set; } // 当前状态
    public T PreviousState { get; private set; } // 上一个状态
    private readonly Dictionary<Type, T> _stateInstances = new(); // 状态实例集合
    private readonly List<StateTransition> _transitions = new(); // 状态过渡集合
    public event Action<T, T> OnStateChanged; // 参数: 旧状态, 新状态
    public StateMachine(){}
    public StateMachine(T initialState){}
    public void AddState(T state){}// 添加状态
    private void AddTransition(T from, T to, Func<bool> condition){}// 添加状态过渡
    public void AddTransition<TFrom, TTo>(Func<bool> condition)where TFrom : class, T where TTo : class, T{}// 添加状态过渡（泛型版本）
    public void ChangeState(T newState){}// 切换状态
    public void ChangeState<TState>() where TState : class, T{}// 切换状态（泛型版本）
    public bool IsInState<TState>() where TState : class, T{}// 检查是否在指定状态
    private TState GetState<TState>() where TState : class, T{}// 获取状态实例
    public void OnUpdate(float deltaTime){}// 更新状态机
    public void OnFixedUpdate(float fixedDeltaTime){}// 固定更新状态机
    private void CheckTransitions(){}// 检查状态过渡条件
    public void Clear(){}// 清空状态机
}

/// <summary>
/// 游戏状态管理器
/// </summary>
public class GameStateManager : MonoSingleton<GameStateManager>
{
    public StateMachine<GameStateBase> StateMachine { get; private set; } // 持有一个游戏状态机
    public void AddCommand(CommandBase commandBase){} // 给状态添加命令
    protected override void OnInitialize(){} // 初始化管理器
    private void InitializeStateMachine(){} // 初始化状态机
    protected override void OnUpdate(){} // 由Unity驱动的更新函数，在这里面驱动状态机更新
    protected override void OnFixedUpdate(){} // 由Unity驱动的更新函数，在这里面驱动状态机更新
    private void OnStateChanged(GameStateBase oldState, GameStateBase newState){} // 状态变化时的额外处理
    protected override void OnDestroy(){}
}

/// <summary>
/// 状态过渡条件
/// </summary>
public struct StateTransition
{
    public IState From { get; }
    public IState To { get; }
    public Func<bool> Condition { get; }

    public StateTransition(IState from, IState to, Func<bool> condition)
    {
        From = from;
        To = to;
        Condition = condition;
    }
}
```

### 2.3 游戏模式系统 (Strategy Pattern)

暂无，待设计

### 2.4 UI系统 (MVVM Pattern)

```csharp
// ViewModel核心接口
public interface IViewModel : IDisposable
{
    string ViewModelName { get; }
    bool IsInitialized { get; }
    void Initialize();
}

// ViewModel基类
public abstract class ViewModelBase : IViewModel
{
    // === IViewModel 实现 ===
    public string ViewModelName => GetType().Name;
    public bool IsInitialized { get; private set; }
    public virtual void Initialize(){} // 初始化ViewModel
    public virtual void Dispose(){} // 释放ViewModel
    // === 可观察属性支持 ===
    private readonly Dictionary<string, IObservable> _observables = new();
    // ✅ 统一访问所有Observable
    public IReadOnlyDictionary<string, IObservable> GetAllObservables() => _observables;
    private IObservable<T> CreateObservable<T>(T initialValue = default, [CallerMemberName] string propertyName = ""){}
    // 通过名称获取泛型可观察属性
    protected IObservable<T> GetObservable<T>([CallerMemberName] string propertyName = null){}
    // === 抽象方法 ===
    protected virtual void InitializeProperties(){}
    protected virtual void OnDispose(){}
}

// 游戏UI ViewModel
public class GameViewModel : ViewModelBase
{
    public Observable<int> Score => GetObservable<int>() as Observable<int>;

    public void PauseGame()
    {
        GameStateManager.Instance.AddCommand(new PauseGameCommand());
    }

    protected override void InitializeProperties()
    {
        base.InitializeProperties();
        OnScoreChanged(string.Empty, ScoreManager.Instance.QueryScore(BirdManager.Instance.MyBird.name));

        ScoreManager.Instance.OnScoreChanged += OnScoreChanged;
    }

    protected override void OnDispose()
    {
        base.OnDispose();
        ScoreManager.Instance.OnScoreChanged -= OnScoreChanged;
    }

    private void OnScoreChanged(string key, int score)
    {
        Score.SetValue(score);
    }
}

// 主菜单 ViewModel
public class MainMenuViewModel : ViewModelBase
{
    public void StartGame()
    {
        GameStateManager.Instance.AddCommand(new StartGameCommand());
    }

    public void OpenSetting()
    {
        GameStateManager.Instance.AddCommand(new OpenSettingCommand());
    }
    
    public void OpenThanks()
    {
        GameStateManager.Instance.AddCommand(new OpenThanksCommand());
    }
}

// 游戏暂停UI ViewModel
public class PauseViewModel : ViewModelBase
{
    public void StartGame()
    {
        GameStateManager.Instance.AddCommand(new PauseGameCommand());
    }
}

// 游戏设置UI ViewModel
public class SettingViewModel : ViewModelBase
{
    public Observable<bool> IsMusicEnabled => GetObservable<bool>() as Observable<bool>;
    public Observable<bool> IsSoundEnabled => GetObservable<bool>() as Observable<bool>;


    public void ReturnMenu()
    {
        GameStateManager.Instance.AddCommand(new ReturnMainMenuCommand());
    }

    public void ToggleMusic(bool arg0)
    {
        SettingManager.Instance.SetMusicEnabled(arg0);
    }

    public void ToggleSound(bool arg0)
    {
        SettingManager.Instance.SetSoundEnabled(arg0);
    }

    protected override void InitializeProperties()
    {
        base.InitializeProperties();

        OnMusicToggleChanged(SettingManager.Instance.IsMusicEnabled);
        OnSoundToggleChanged(SettingManager.Instance.IsSoundEnabled);
        
        SettingManager.Instance.OnMusicToggleChanged += OnMusicToggleChanged;
        SettingManager.Instance.OnSoundToggleChanged += OnSoundToggleChanged;
    }

    protected override void OnDispose()
    {
        base.OnDispose();

        SettingManager.Instance.OnMusicToggleChanged -= OnMusicToggleChanged;
        SettingManager.Instance.OnSoundToggleChanged -= OnSoundToggleChanged;
    }

    private void OnMusicToggleChanged(bool obj)
    {
        IsMusicEnabled.SetValue(obj);
    }

    private void OnSoundToggleChanged(bool obj)
    {
        IsSoundEnabled.SetValue(obj);
    }
}

// 感谢名单ui ViewModel
public class ThanksViewModel : ViewModelBase
{
    public void ReturnMenu(){} // 返回主菜单
}

// 感谢名单ui ViewModel
public class GameOverViewModel : ViewModelBase
{
    public Observable<int> Score => GetObservable<int>() as Observable<int>;

    public void RestartGame()
    {
        GameStateManager.Instance.AddCommand(new ReStartGameCommand());
    }

    public void ReturnMainMenu()
    {
        GameStateManager.Instance.AddCommand(new ReturnMainMenuCommand());
    }

    protected override void InitializeProperties()
    {
        base.InitializeProperties();
        OnScoreChanged(string.Empty, ScoreManager.Instance.QueryScore(BirdManager.Instance.MyBird.name));
        ScoreManager.Instance.OnScoreChanged += OnScoreChanged;
    }

    protected override void OnDispose()
    {
        base.OnDispose();
        ScoreManager.Instance.OnScoreChanged -= OnScoreChanged;
    }

    private void OnScoreChanged(string key, int score)
    {
        Score.SetValue(score);
    }
}


// 可观察数据 非泛型基础接口
public interface IObservable
{
    event Action<object> OnValueChanged;
    object Value { get; }
    Type ValueType { get; }
    void SetValue(object value);
}

// 可观察数据 泛型接口（继承基础接口）
public interface IObservable<T> : IObservable
{
    new event Action<T> OnValueChanged;
    new T Value { get; }
    void SetValue(T value);
}

// 可观察数据基类
public class Observable<T> : IObservable<T>
{
    public T Value => _value;// 泛型属性
    public Type ValueType => typeof(T);
    public event Action<T> OnValueChanged;// 泛型事件
    public void SetValue(T value){}
    public void SetValue(object value){}
    public Observable(T initialValue = default){}
    public override string ToString(){}        
    private T _value; 
    object IObservable.Value => _value;   // 非泛型属性（显式实现）  
    private Action<object> _objectValueChanged;
    event Action<object> IObservable.OnValueChanged  // 非泛型事件（显式实现）
    {
        add => _objectValueChanged += value;
        remove => _objectValueChanged -= value;
    }
}

// UI基类
public class UIBase : MonoBehaviour
{
    private readonly List<IViewModel> _viewModels = new(); // UI访问的ViewModel列表
    public string UIName => GetType().Name;
    public bool IsVisible => _isVisible;
    private bool _isVisible = false;
    public virtual void Initialize(){} // UI预制体被加载上来时的处理
    public virtual void Show(Action onComplete = null){}
    public virtual void Hide(Action onComplete = null){}
    public virtual void Destroy(){}
    protected T GetViewModel<T>() where T : class, IViewModel, new(){} // 访问某个ViewModel
    protected virtual void OnShow(){}
    protected virtual void OnHide(){}
    protected virtual void OnDestroy(){}
    private void ReleaseAllViewModels(){} // 释放所有访问的ViewModel
}

// 确认弹窗的UI
public class ConfirmDialogUI : UIBase
{
    [SerializeField] private TextMeshProUGUI titleText;
    [SerializeField] private TextMeshProUGUI messageText;
    [SerializeField] private Button confirmButton;
    [SerializeField] private Button cancelButton;
    private Action _onConfirm;
    private Action _onCancel;
    public override void Initialize(){}
    public void Show(ConfirmDialogUIData config){}
    private void OnClickConfirmButton(){}
    private void OnClickCancelButton(){}
}

// 确认弹窗界面打开时用到的数据
public struct ConfirmDialogUIData
{
    public string Title;
    public string Message;
    public Action OnConfirm;
    public Action OnCancel;
}

// 游戏结束UI
public class GameOverUI : UIBase
{
    [SerializeField] private TextMeshProUGUI scoreText;
    [SerializeField] private Button reStartButton;
    [SerializeField] private Button returnMainMenuButton;
    public override void Initialize(){}
    protected override void OnShow(){}
    private void OnReturnMainMenuButtonClicked(){}
    private void OnReStartButtonClicked(){}
}

// 游戏UI
public class GameUI : UIBase
{
    [SerializeField] private Button pauseButton;
    [SerializeField] private TextMeshProUGUI scoreText;

    public override void Initialize(){}
    private void UpdateScore(int obj){}
    protected override void OnShow(){}
    protected override void OnHide(){}
    private void OnPauseButtonClicked(){}
}

public struct LoadUIConfig
{
    public string UIName;
    public Action<UIBase> OnComplete;

    public Transform Parent;
}

public struct LoadUIConfig<T> where T : UIBase
{
    public string UIName;
    public Action<T> OnComplete;

    public Transform Parent;
}

public class ConfigBase : ScriptableObject
{
        
}

public class ViewModelScope : ConfigBase
{
    [Serializable]
    public class ViewModelLifetime
    {
        // 改为 string 类型来存储类型名称
        public string viewModelTypeName;
        public ViewModelContainer.LifetimeScope lifetime = ViewModelContainer.LifetimeScope.Scene;

        // 提供一个属性来在运行时获取 Type 对象
        public Type ViewModelType
        {
            get => string.IsNullOrEmpty(viewModelTypeName) ? null : Type.GetType(viewModelTypeName);
            set => viewModelTypeName = value?.AssemblyQualifiedName;
        }
    }

    public List<ViewModelLifetime> viewModels = new();
}

public class ViewModelContainer : MonoSingleton<ViewModelContainer>
{
    public enum LifetimeScope
    {
        Scene, // 场景切换时销毁
        Manual, // 手动管理
        Permanent // 永久存在（谨慎使用）
    }

    private readonly Dictionary<Type, IViewModel> _viewModels = new();
    private readonly Dictionary<Type, LifetimeScope> _lifetimeScopes = new();
    private readonly Dictionary<Type, int> _referenceCounts = new();

    private bool _initialized;
    private const string ConfigPath = "Assets/Configs/ViewModelScopeConfig.asset";

    public T GetViewModel<T>() where T : class, IViewModel, new()
    {
        if (!IsValid())
        {
            Debug.LogError("ViewModelContainer,Not Initialized");
            return null;
        }

        var type = typeof(T);

        if (!_viewModels.TryGetValue(type, out var vm))
        {
            vm = new T();
            vm.Initialize();
            _viewModels[type] = vm;
            _referenceCounts[type] = 0;
        }

        _referenceCounts[type]++;
        return vm as T;
    }

    public void ReleaseViewModel<T>() where T : class, IViewModel
    {
        if (!IsValid())
        {
            Debug.LogError("ViewModelContainer,Not Initialized");
            return;
        }

        var type = typeof(T);
        ReleaseViewModel(type);
    }

    public void ReleaseViewModel(IViewModel viewModel)
    {
        if (!IsValid())
        {
            Debug.LogError("ViewModelContainer,Not Initialized");
            return;
        }

        var type = viewModel.GetType();
        ReleaseViewModel(type);
    }

    public bool IsValid()
    {
        return _initialized;
    }

    private bool ShouldDestroyViewModel(Type viewModelType)
    {
        if (!_referenceCounts.TryGetValue(viewModelType, out var count) || count > 0)
            return false;

        if (!_lifetimeScopes.TryGetValue(viewModelType, out var lifetime))
            return true; // 未配置的默认销毁

        return lifetime != LifetimeScope.Permanent;
    }

    private void DestroyViewModel(Type viewModelType)
    {
        if (!_viewModels.TryGetValue(viewModelType, out var vm)) return;
        vm.Dispose();
        _viewModels.Remove(viewModelType);
        _referenceCounts.Remove(viewModelType);
    }

    protected override void OnInitialize()
    {
        base.OnInitialize();

        StartCoroutine(LoadConfig());
    }

    private IEnumerator LoadConfig()
    {
        var handle = Addressables.LoadAssetAsync<ViewModelScope>(ConfigPath);
        yield return handle;

        // 检查加载是否成功
        if (handle.Status != AsyncOperationStatus.Succeeded || handle.Result == null)
        {
            Debug.LogError($"Failed to load ViewModelScopeConfig from path: {ConfigPath}");
            yield break;
        }

        var configData = handle.Result;

        // 配置生命周期
        foreach (var config in configData.viewModels)
        {
            // 安全获取 Type
            var viewModelType = config.ViewModelType;
            if (viewModelType == null)
            {
                Debug.LogWarning($"Skipping config with null ViewModelType: {config.viewModelTypeName}");
                continue;
            }

            // 检查重复类型
            if (_lifetimeScopes.ContainsKey(viewModelType))
            {
                Debug.LogWarning($"Duplicate ViewModelType found: {viewModelType.Name}. Using latest value.");
            }

            _lifetimeScopes[viewModelType] = config.lifetime;
        }

        _initialized = true;
        Debug.Log($"Successfully loaded {_lifetimeScopes.Count} view model configurations.");
    }

    private void ReleaseViewModel(Type type)
    {
        if (!_referenceCounts.TryGetValue(type, out var count)) return;
        _referenceCounts[type] = count - 1;

        // 根据生命周期决定是否销毁
        if (ShouldDestroyViewModel(type))
        {
            DestroyViewModel(type);
        }
    }
}

```

## 3. 核心管理器类设计

### 3.1 MonoSingleton

```csharp
/// <summary>
/// Unity MonoBehaviour 泛型单例
/// 自动创建游戏对象并附加组件
/// </summary>
/// <typeparam name="T">继承MonoBehaviour的单例类型</typeparam>
public class MonoSingleton<T> : MonoBehaviour where T : MonoSingleton<T>
{
    private static T _instance; // 单例对象
    protected static bool _isApplicationQuitting = false; // 判断编辑器是否正在退出，如果在退出，就不创建单例了
    public static T Instance{get;} // 这里动态创建一个GameObject来挂载单例脚本
    
    private void Update() // MonoBehaviour的生命周期函数，用来驱动单例内部逻辑
    private void FixedUpdate() //MonoBehaviour的生命周期函数，用来驱动单例内部逻辑
    protected virtual void Awake() // 管理器节点被创建出来时的处理
    protected virtual void OnDestroy() // 管理器节点被销毁时的处理
    protected virtual void OnInitialize() { }    // 初始化方法，在Awake中自动调用
    protected virtual void OnUpdate() { } // 更新方法，在Update中自动调用
    protected virtual void OnFixedUpdate() { } // 更新方法，在Update中自动调用
    private void OnApplicationQuit()  // 游戏退出时的处理
}
```

### 3.2 模式管理器

暂无 待设计

### 3.3 数据管理层 (Repository Pattern)

暂无 待设计

### 3.4 其余模块的管理器

```csharp
public class UIManager : MonoSingleton<UIManager>
{
    private Transform _uiRoot; // UI父节点
    private readonly Dictionary<string, UIBase> _loadedUIs = new(); // 已加载的UI字典
    private readonly Dictionary<string, AsyncOperationHandle<GameObject>> _uiHandles = new(); // Addressable资源句柄字典

    private const string UICanvasName = "UICanvas";

    public void ShowMenuPanel()
    {
        ShowUI(new LoadUIConfig { UIName = UIScreen.MainMenu });
    }

    public void HideMenuPanel()
    {
        HideUI(UIScreen.MainMenu);
    }

    public void ShowGamePanel()
    {
        ShowUI(new LoadUIConfig { UIName = UIScreen.Game });
    }

    public void HideGamePanel()
    {
        HideUI(UIScreen.Game);
    }

    public void ShowPausePanel()
    {
        ShowUI(new LoadUIConfig { UIName = UIScreen.Pause });
    }

    public void HidePausePanel()
    {
        HideUI(UIScreen.Pause);
    }

    public void ShowGameOverPanel()
    {
        ShowUI(new LoadUIConfig { UIName = UIScreen.GameOver });
    }

    public void HideGameOverPanel()
    {
        HideUI(UIScreen.GameOver);
    }

    public void ShowSettingPanel()
    {
        ShowUI(new LoadUIConfig { UIName = UIScreen.Settings });
    }

    public void HideSettingPanel()
    {
        HideUI(UIScreen.Settings);
    }
    
    public void ShowThanksPanel()
    {
        ShowUI(new LoadUIConfig { UIName = UIScreen.Thanks });
    }

    public void HideThanksPanel()
    {
        HideUI(UIScreen.Thanks);
    }



    public void ShowUI<T>(LoadUIConfig<T> config) where T : UIBase
    {
        if (!IsValid())
        {
            Debug.LogError("UI系统未初始化");
            return;
        }

        var uiName = config.UIName;
        var onComplete = config.OnComplete;
        if (config.Parent == null) config.Parent = _uiRoot;

        if (!_loadedUIs.ContainsKey(uiName))
        {
            LoadUI(config, OnLoaded);
        }
        else
        {
            OnLoaded(true);
        }

        return;

        void OnLoaded(bool success)
        {
            if (!success)
            {
                Debug.LogError($"加载UI失败: {uiName}");
                onComplete?.Invoke(null);
                return;
            }

            var ui = _loadedUIs[uiName];
            ui.Show(() => { onComplete?.Invoke(ui as T); });
        }
    }


    // 显示UI
    public void ShowUI(LoadUIConfig config)
    {
        if (!IsValid())
        {
            Debug.LogError("UI系统未初始化");
            return;
        }

        var uiName = config.UIName;
        var onComplete = config.OnComplete;
        if (config.Parent == null) config.Parent = _uiRoot;

        if (!_loadedUIs.ContainsKey(uiName))
        {
            LoadUI(config, OnLoaded);
        }
        else
        {
            OnLoaded(true);
        }

        return;

        void OnLoaded(bool success)
        {
            if (!success)
            {
                Debug.LogError($"加载UI失败: {uiName}");
                onComplete?.Invoke(null);
                return;
            }

            var ui = _loadedUIs[uiName];
            ui.Show(() => { onComplete?.Invoke(ui); });
        }
    }

    // 隐藏指定UI
    public void HideUI(string uiName)
    {
        if (!_loadedUIs.TryGetValue(uiName, out var ui))
        {
            Debug.LogError($"UI:{uiName}未加载");
            return;
        }

        ui.Hide();
    }

    // 预加载多个UI
    public void PreloadUIs(LoadUIConfig[] configs, Action<int> onProgress = null, Action onComplete = null)
    {
        StartCoroutine(PreloadUIsRoutine(configs, onProgress, onComplete));
    }

    private IEnumerator PreloadUIsRoutine(LoadUIConfig[] configs, Action<int> onProgress, Action onComplete)
    {
        var loadedCount = 0;

        foreach (var config in configs)
        {
            if (_loadedUIs.ContainsKey(config.UIName))
            {
                loadedCount++;
                onProgress?.Invoke(loadedCount * 100 / configs.Length);
                continue;
            }

            var loadCompleted = false;
            var loadSuccess = false;

            LoadUI(config, (success) =>
            {
                loadCompleted = true;
                loadSuccess = success;
            });

            // 等待这个UI加载完成
            yield return new WaitUntil(() => loadCompleted);

            if (!loadSuccess) continue;

            loadedCount++;
            onProgress?.Invoke(loadedCount * 100 / configs.Length);
        }

        onComplete?.Invoke();
    }

    // 获取UI实例
    public T GetUI<T>(string uiName) where T : UIBase
    {
        if (_loadedUIs.TryGetValue(uiName, out var i))
        {
            return i as T;
        }

        return null;
    }

    // 卸载UI
    private void UnloadUI(string uiName)
    {
        if (!_loadedUIs.TryGetValue(uiName, out var ui))
        {
            Debug.LogError($"UI:{uiName}未加载");
            return;
        }

        // 销毁GameObject
        ui.Destroy();
        _loadedUIs.Remove(uiName);

        // 释放Addressable资源
        if (!_uiHandles.TryGetValue(uiName, out var handle)) return;
        Addressables.Release(handle);
        _uiHandles.Remove(uiName);
    }

    private void LoadUI<T>(LoadUIConfig<T> config, Action<bool> onComplete = null) where T : UIBase
    {
        var uiName = config.UIName;
        var parent = config.Parent;
        if (_loadedUIs.ContainsKey(uiName))
        {
            Debug.LogWarning($"UI {uiName} 已经加载");
            onComplete?.Invoke(true);
            return;
        }

        if (_uiHandles.ContainsKey(uiName))
        {
            Debug.LogWarning($"UI {uiName} 正在加载中");
            return;
        }

        // 开始异步加载，但提供同步接口
        StartCoroutine(LoadUIRoutine(config, onComplete));
    }

    // 同步接口：加载UI（立即返回，内部异步加载）
    private void LoadUI(LoadUIConfig config, Action<bool> onComplete = null)
    {
        var uiName = config.UIName;
        var parent = config.Parent;
        if (_loadedUIs.ContainsKey(uiName))
        {
            Debug.LogWarning($"UI {uiName} 已经加载");
            onComplete?.Invoke(true);
            return;
        }

        if (_uiHandles.ContainsKey(uiName))
        {
            Debug.LogWarning($"UI {uiName} 正在加载中");
            return;
        }

        // 开始异步加载，但提供同步接口
        StartCoroutine(LoadUIRoutine(config, onComplete));
    }

    private IEnumerator LoadUIRoutine<T>(LoadUIConfig<T> config, Action<bool> onComplete = null) where T : UIBase
    {
        var uiName = config.UIName;
        var parent = config.Parent;

        // 异步加载Addressable资源
        var handle = Addressables.LoadAssetAsync<GameObject>(GetUIPath(uiName));
        _uiHandles[uiName] = handle;

        // 等待加载完成
        yield return handle;

        if (handle.Status == AsyncOperationStatus.Succeeded)
        {
            var instance = Instantiate(handle.Result, parent);
            Addressables.Release(handle);
            _uiHandles.Remove(uiName);

            var uiComponent = instance.GetComponent<UIBase>();

            if (uiComponent != null)
            {
                uiComponent.Initialize();
                uiComponent.Hide(); // 默认隐藏
                _loadedUIs[uiName] = uiComponent;
                onComplete?.Invoke(true);
            }
            else
            {
                Debug.LogError($"UI {uiName} 没有UIBase组件");
                onComplete?.Invoke(false);
            }
        }
        else
        {
            Debug.LogError($"加载UI失败: {uiName}");
            Addressables.Release(handle);
            _uiHandles.Remove(uiName);
            onComplete?.Invoke(false);
        }
    }

    // 内部协程处理异步加载
    private IEnumerator LoadUIRoutine(LoadUIConfig config, Action<bool> onComplete = null)
    {
        var uiName = config.UIName;
        var parent = config.Parent;

        // 异步加载Addressable资源
        var handle = Addressables.LoadAssetAsync<GameObject>(GetUIPath(uiName));
        _uiHandles[uiName] = handle;

        // 等待加载完成
        yield return handle;

        if (handle.Status == AsyncOperationStatus.Succeeded)
        {
            var instance = Instantiate(handle.Result, parent);
            Addressables.Release(handle);
            _uiHandles.Remove(uiName);

            var uiComponent = instance.GetComponent<UIBase>();

            if (uiComponent != null)
            {
                uiComponent.Initialize();
                uiComponent.Hide(); // 默认隐藏
                _loadedUIs[uiName] = uiComponent;
                onComplete?.Invoke(true);
            }
            else
            {
                Debug.LogError($"UI {uiName} 没有UIBase组件");
                onComplete?.Invoke(false);
            }
        }
        else
        {
            Debug.LogError($"加载UI失败: {uiName}");
            Addressables.Release(handle);
            _uiHandles.Remove(uiName);
            onComplete?.Invoke(false);
        }
    }

    private bool IsValid()
    {
        return _uiRoot != null;
    }

    protected override void OnInitialize()
    {
        base.OnInitialize();

        var obj = GameObject.FindGameObjectWithTag(UICanvasName);
        if (obj == null)
        {
            Debug.LogError("找不到 DefaultCanvas 游戏对象");
            return;
        }

        _uiRoot = obj.transform;
    }

    private string GetUIPath(string viewName)
    {
        return $"Assets/Prefabs/UI/Views/{viewName}.prefab";
    }
}

public class SettingManager : MonoSingleton<SettingManager>
{
    public bool IsMusicEnabled { get; private set; }
    public bool IsSoundEnabled { get; private set; }
    
    public event Action<bool> OnMusicToggleChanged;
    public event Action<bool> OnSoundToggleChanged;

    private const string MusicEnabledKey = "MusicEnabled";
    private const string SoundEnabledKey = "SoundEnabled";
    
    protected override void OnInitialize()
    {
        base.OnInitialize();
        IsMusicEnabled = PlayerPrefs.GetInt(MusicEnabledKey, 1) == 1;
        IsSoundEnabled = PlayerPrefs.GetInt(SoundEnabledKey, 1) == 1;
    }

    public void SetMusicEnabled(bool arg0)
    {
        IsMusicEnabled = arg0;
        PlayerPrefs.SetInt(MusicEnabledKey, arg0 ? 1 : 0);
        OnMusicToggleChanged?.Invoke(arg0);
    }

    public void SetSoundEnabled(bool arg0)
    {
        IsSoundEnabled = arg0;
        PlayerPrefs.SetInt(SoundEnabledKey, arg0 ? 1 : 0);
        OnSoundToggleChanged?.Invoke(arg0);
    }
}


public class ScoreManager : MonoSingleton<ScoreManager>
{
    public event Action<string, int> OnScoreChanged;
    private readonly Dictionary<string, int> _scores = new();

    public void AddScore(string key, int score)
    {
        if (!_scores.TryAdd(key, score))
        {
            _scores[key] = score + _scores[key];
        }

        OnScoreChanged?.Invoke(key, _scores[key]);
    }

    public int QueryScore(string key)
    {
        return _scores.GetValueOrDefault(key, 0);
    }

    public void ClearAllScores()
    {
        foreach (var kv in _scores)
        {
            OnScoreChanged?.Invoke(kv.Key, 0);
        }
        _scores.Clear();
    }
}

/// <summary>
/// 对象池管理器
/// </summary>
public class PoolManager : MonoSingleton<PoolManager>
{
    protected override void OnInitialize()
    {
        base.OnInitialize();
        PreloadPools();
        Debug.Log("PoolManager 初始化完成");
    }

    /// <summary>
    /// 预加载所有对象池
    /// </summary>
    private void PreloadPools()
    {
        // 这里可以预加载常用的对象池
        // 例如：子弹、特效、敌人等
    }

    /// <summary>
    /// 显示对象池统计信息
    /// </summary>
    public void LogPoolStats()
    {
        GameObjectPool.Instance.GetPoolStats(out var stats);
        
        foreach (var stat in stats)
        {
            Debug.Log($"对象池 [{stat.Key}]: 活跃={stat.Value.active}, 闲置={stat.Value.inactive}");
        }
    }
}


public class ConfirmDialogManager : MonoSingleton<ConfirmDialogManager>
{
    private Transform _container;
    
    public void ShowConfirmDialog(ConfirmDialogUIData uiData)
    {
        if (!IsValid()) return;
        
        UIManager.Instance.ShowUI(new LoadUIConfig<ConfirmDialogUI>
        {
            UIName = UIScreen.ConfirmDialog,
            Parent = _container,
            OnComplete = ui =>
            {
                ui.Show(uiData);
            }
        });
    }

    public void CloseConfirmDialog(int dialogId)
    {
        if (!IsValid()) return;
    }

    private bool IsValid()
    {
        return _container != null;
    }

    protected override void OnInitialize()
    {
        base.OnInitialize();

        var obj = GameObject.FindGameObjectWithTag("DialogCanvas");
        if (obj == null)
        {
            Debug.LogError("找不到 DialogCanvas 游戏对象");
            return;
        }
        _container = obj.transform;
    }
}


public class BirdManager : MonoSingleton<BirdManager>
{
    public List<BirdController> Birds { get; } = new();
    
    private const string BirdControllerTag = "BirdController";

    public BirdController MyBird => Birds[0]; // 临时用第一个小鸟作为自己的小鸟，后续要重构

    public void InitializeBirds()
    {
        
    }
    
    protected override void OnInitialize()
    {
        base.OnInitialize();

        // 后续要重构，现在是直接获取所有的小鸟，应该由服务器下发小鸟的位置，然后动态创建小鸟，并设置位置
        var objs = GameObject.FindGameObjectsWithTag(BirdControllerTag);
        foreach (var obj in objs)
        {
            var controller = obj.GetComponent<BirdController>();
            if (controller != null)
            {
                Birds.Add(controller);
            }
        }
    }
}


public class AudioManager : MonoSingleton<AudioManager>
{
    private readonly Dictionary<string, AudioClip> _audioClips = new();
    private readonly Dictionary<string, AsyncOperationHandle<AudioClip>> _asyncOperationHandles = new();
    private AudioSource _audioSource;

    private const string AudioPlayerTag = "AudioPlayer";

    public void PlayBackgroundMusic(string audioName)
    {
    }

    public void PlaySound(string audioName)
    {
        if (_audioClips.TryGetValue(audioName, out var clip))
        {
            PlaySoundInternal(clip);
        }
        else
        {
            StartCoroutine(LoadAudio(audioName, PlaySoundInternal));
        }

        return;

        void PlaySoundInternal(AudioClip audioClip)
        {
            _audioSource.PlayOneShot(audioClip);
            Debug.Log($"Play sound {audioName} success");
        }
    }

    private IEnumerator LoadAudio(string audioName, Action<AudioClip> callback)
    {
        if (_asyncOperationHandles.ContainsKey(audioName))
        {
            yield break;
        }

        var handle = Addressables.LoadAssetAsync<AudioClip>(GetAudioPath(audioName));
        _asyncOperationHandles.Add(audioName, handle);
        yield return handle;
        Debug.Log($"Load audio {audioName} success");
        _audioClips.TryAdd(audioName, handle.Result);
        callback?.Invoke(handle.Result);
    }

    private string GetAudioPath(string audioName)
    {
        return $"Assets/Audios/Sounds/{audioName}.ogg";
    }

    protected override void OnInitialize()
    {
        base.OnInitialize();

        var obj = GameObject.FindGameObjectWithTag(AudioPlayerTag);
        _audioSource = obj.GetComponent<AudioSource>();
    }
}
```

## 4. 实体组件设计

### 4.1 小鸟控制器

```csharp
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.EventSystems;

public class BirdController : MonoBehaviour, IController
{
    [SerializeField] private float jumpVelocity = 5f;
    [SerializeField] private Transform birdBirthPoint;
    private Rigidbody2D _rb;
    private BirdTrajectoryData _currentTrajectory;
    private int _logicFrame;
    private bool _jumpAtThisFrame;
    private bool _canJump = true;
    private Vector2 _oldVelocity;
    private PointerEventData _eventData;
    private int _uiLayer;

    private const string CollisionTag = "Obstacle";
    private const string ScoreTriggerTag = "ScoreTrigger";

    private readonly List<string> _jumpSounds = new()
    {
        "impactSoft_heavy_000",
        "impactSoft_heavy_001",
        "impactSoft_heavy_002",
        "impactSoft_heavy_003",
        "impactSoft_heavy_004",
    };

    public void ResetBird()
    {
        transform.position = birdBirthPoint.position;
        _rb.gravityScale = 0;
        _rb.velocity = Vector2.zero;
        _oldVelocity = Vector2.zero;
        _canJump = false;
    }

    public void StartBird()
    {
        _rb.velocity = _oldVelocity;
        _oldVelocity = Vector2.zero;

        _rb.gravityScale = 100;
        _canJump = true;
    }

    public void PauseBird()
    {
        if (_oldVelocity == Vector2.zero) _oldVelocity = _rb.velocity;
        _rb.gravityScale = 0;
        _rb.velocity = Vector2.zero;
        _canJump = false;
    }

    private void Jump()
    {
        _rb.velocity = new Vector2(0, jumpVelocity);
        var audioName = _jumpSounds[Random.Range(0, _jumpSounds.Count)];
        AudioManager.Instance.PlaySound(audioName);
    }

    private void Awake()
    {
        _rb = GetComponent<Rigidbody2D>();
        _eventData = new PointerEventData(EventSystem.current);
        _uiLayer = LayerMask.NameToLayer("UI");
        ResetBird();
    }

    // Update is called once per frame
    private void Update()
    {
        if (!_canJump) return;
        // 优先使用触摸输入
        if (Input.touchCount > 0)
        {
            var touch = Input.GetTouch(0);
        
            if (touch.phase == TouchPhase.Began)
            {
                if (IsPointerOverUIElement(touch.position)) return;
                _jumpAtThisFrame = true;
            }
        }else if(Input.GetMouseButtonDown(0))
        {
            if (IsPointerOverUIElement(Input.mousePosition)) return;
            _jumpAtThisFrame = true;
        }
    }

    private void FixedUpdate()
    {
        // 目前先设计成，只接受最近的一次输入
        if (_jumpAtThisFrame)
        {
            _jumpAtThisFrame = false;
            Jump();
            Debug.Log($"Jump at logicFrame:{_logicFrame}");
        }

        _logicFrame += 1;
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        CheckCollision(other.gameObject);
    }

    private void CheckCollision(GameObject other)
    {
        if (other.CompareTag(CollisionTag))
        {
            GameStateManager.Instance.AddCommand(new GameOverCommand());
        }
        else if (other.CompareTag(ScoreTriggerTag))
        {
            GameStateManager.Instance.AddCommand(new AddScoreCommand
                { Args = new AddScoreArgs { Score = 1, Target = name } });
        }
    }

    private bool IsPointerOverUIElement(Vector2 position)
    {
        return IsPointerOverUIElement(GetEventSystemRaycastResults(position));
    }

    private bool IsPointerOverUIElement(List<RaycastResult> eventSystemRaycastResults)
    {
        return eventSystemRaycastResults.Any(raycastResult => raycastResult.gameObject.layer == _uiLayer);
    }

    private List<RaycastResult> GetEventSystemRaycastResults(Vector2 position)
    {
        _eventData.position = position;
        var raycastResults = new List<RaycastResult>();
        EventSystem.current.RaycastAll(_eventData, raycastResults);
        return raycastResults;
    }
}
```

### 4.2 管道生成器 (Object Pool + Builder Pattern)

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AddressableAssets;

public class PipeSpawner : MonoSingleton<PipeSpawner>
{
    private const string PipePoolName = "PipePool";
    private const string PipeTriggerPoolName = "PipeTriggerPool";
    private const string GlobalConfigPath = "Assets/Configs/GlobalConfig.asset";
    private const string WorldCanvasTag = "WorldCanvas";


    private readonly List<BaseSceneComController> _sceneComs = new();
    private float _timer;
    private bool _isSpawning;
    private GlobalConfig _globalConfig;
    private bool _isInitialized;
    private Transform _parent;

    public void StartSpawning()
    {
        _isSpawning = true;
        _timer = 0f;
        SpawnOnePairPipe();
    }

    public void PauseSpawning()
    {
        _isSpawning = false;
        foreach (var pipe in _sceneComs)
        {
            pipe.StopMove();
        }
    }

    public void ResumeSpawning()
    {
        _isSpawning = true;
        foreach (var pipe in _sceneComs)
        {
            pipe.ResumeMove();
        }
    }

    public bool IsValid()
    {
        return _isInitialized;
    }

    /// <summary>
    /// 回收所有管道
    /// </summary>
    public void ReturnAllPipes()
    {
        foreach (var pipe in _sceneComs)
        {
            GameObjectPool.Instance.Return(pipe.gameObject);
        }

        _sceneComs.Clear();
    }

    public void ReturnPipe(BaseSceneComController pipe)
    {
        GameObjectPool.Instance.Return(pipe.gameObject);
        _sceneComs.Remove(pipe);
    }

    protected override void OnInitialize()
    {
        base.OnInitialize();

        StartCoroutine(InitializeAsync());
    }


    protected override void OnUpdate()
    {
        base.OnUpdate();
        if (!_isSpawning) return;

        _timer += Time.deltaTime;

        if (_timer < _globalConfig.spawnInterval) return;
        _timer = 0f;
        SpawnOnePairPipe();
    }

    private void SpawnOnePairPipe()
    {
        SpawnPipe(_globalConfig.pipeCenterY, _globalConfig.pipeIntervalY, _globalConfig.spawnXPosition,
            _globalConfig.pipeMoveSpeed);
        SpawnTrigger(_globalConfig.spawnXPosition + _globalConfig.pipeTriggerOffsetX, _globalConfig.pipeMoveSpeed);
    }

    private void SpawnPipe(Vector2 pipeCenterY, Vector2 pipeIntervalY, float pipeXPosition, float pipeMoveSpeed)
    {
        var randomY = Random.Range(pipeCenterY.x, pipeCenterY.y);
        var randomIntervalY = Random.Range(pipeIntervalY.x, pipeIntervalY.y);

        var spawnPosition1 = new Vector3(pipeXPosition, randomY + randomIntervalY / 2, 0f);
        var spawnPosition2 = new Vector3(pipeXPosition, randomY - randomIntervalY / 2, 0f);
        SpawnPipe(spawnPosition1, pipeMoveSpeed, true);
        SpawnPipe(spawnPosition2, pipeMoveSpeed, false);
    }

    private void SpawnPipe(Vector3 spawnPosition, float moveSpeed, bool isUp)
    {
        var pipe = GameObjectPool.Instance.Get(PipePoolName, spawnPosition, Quaternion.identity);
        var rect = pipe.GetComponent<RectTransform>();
        rect.pivot = new Vector2(0.5f, isUp ? 0f : 1f);

        var col = pipe.GetComponent<BoxCollider2D>();
        col.offset = new Vector2(col.offset.x, isUp ? col.size.y / 2 : -col.size.y / 2);

        if (pipe == null) return;
        var controller = pipe.GetComponent<PipeController>();
        _sceneComs.Add(controller);
        // 设置管道移动
        controller.StartMove(moveSpeed);
    }

    private void SpawnTrigger(float spawnXPosition, float moveSpeed)
    {
        var spawnPosition = new Vector3(spawnXPosition, 0f, 0f);
        var pipe = GameObjectPool.Instance.Get(PipeTriggerPoolName, spawnPosition, Quaternion.identity);
        if (pipe == null) return;
        var controller = pipe.GetComponent<PipeTriggerController>();
        _sceneComs.Add(controller);
        // 设置管道移动
        controller.StartMove(moveSpeed);
    }

    private IEnumerator InitializeAsync()
    {
        yield return LoadConfig();
        CreatePool();
        _parent = GameObject.FindGameObjectWithTag(WorldCanvasTag).transform;
        _isInitialized = true;
    }

    private IEnumerator LoadConfig()
    {
        var handle = Addressables.LoadAssetAsync<GlobalConfig>(GlobalConfigPath);
        yield return handle;

        _globalConfig = handle.Result;
    }

    private void CreatePool()
    {
        // 创建管道对象池
        var pipePoolConfig = new GameObjectPool.PoolConfig
        {
            poolName = PipePoolName,
            prefab = _globalConfig.pipePrefab,
            initialSize = 5,
            maxSize = 20,
            poolParent = transform,
            OnUsed = OnUsePipe,
            OnRecycled = OnRecyclePipe,
        };

        GameObjectPool.Instance.CreatePool(pipePoolConfig);

        // 创建管道触发器，用来检测小鸟是否飞过管道
        var pipeTriggerPoolConfig = new GameObjectPool.PoolConfig
        {
            poolName = PipeTriggerPoolName,
            prefab = _globalConfig.pipeTriggerPrefab,
            initialSize = 5,
            maxSize = 20,
            poolParent = transform,
            OnUsed = OnUsePipe,
            OnRecycled = OnRecyclePipe,
        };

        GameObjectPool.Instance.CreatePool(pipeTriggerPoolConfig);
    }

    private void OnRecyclePipe(GameObject obj)
    {
        var controller = obj.GetComponent<BaseSceneComController>();
        controller.OnRecycle();
    }

    private void OnUsePipe(GameObject obj)
    {
        obj.transform.SetParent(_parent);

        var controller = obj.GetComponent<BaseSceneComController>();
        controller.OnUse();
    }
}

/// <summary>
/// Unity GameObject 对象池
/// </summary>
public class GameObjectPool : MonoSingleton<GameObjectPool>
{
    [System.Serializable]
    public class PoolConfig
    {
        public string poolName;
        public GameObject prefab;
        public int initialSize = 10;
        public int maxSize = 50;
        public Transform poolParent;
        public Action<GameObject> OnUsed;
        public Action<GameObject> OnRecycled;
    }

    [SerializeField] private List<PoolConfig> poolConfigs = new();

    private readonly Dictionary<string, ObjectPool<GameObject>> _pools = new();
    private readonly Dictionary<GameObject, string> _objectToPoolMap = new();

    protected override void OnInitialize()
    {
        base.OnInitialize();
        InitializePools();
    }

    private void InitializePools()
    {
        foreach (var config in poolConfigs)
        {
            CreatePool(config);
        }
    }

    /// <summary>
    /// 创建对象池
    /// </summary>
    public void CreatePool(PoolConfig config)
    {
        if (_pools.ContainsKey(config.poolName))
        {
            Debug.LogWarning($"对象池 {config.poolName} 已存在");
            return;
        }

        var pool = new ObjectPool<GameObject>(
            createFunc: () => CreateNewObject(config),
            onGet: obj=> OnGetObject(obj, config),
            onReturn:  obj=> OnReturnObject(obj, config),
            onDestroy: Destroy,
            initialSize: config.initialSize,
            maxSize: config.maxSize
        );

        _pools.Add(config.poolName, pool);
    }

    private GameObject CreateNewObject(PoolConfig config)
    {
        var obj = Instantiate(config.prefab, config.poolParent ?? transform, true);
        obj.SetActive(false);

        // 添加池对象组件以便自动归还
        var poolObject = obj.GetComponent<PooledObject>() ?? obj.AddComponent<PooledObject>();
        poolObject.PoolName = config.poolName;

        _objectToPoolMap[obj] = config.poolName;

        return obj;
    }

    private void OnGetObject(GameObject obj, PoolConfig config)
    {
        obj.SetActive(true);
        obj.transform.SetParent(config.poolParent);
        config.OnUsed?.Invoke(obj);
    }

    private void OnReturnObject(GameObject obj, PoolConfig config)
    {
        obj.SetActive(false);
        obj.transform.SetParent(GetPoolParent(obj));
        config.OnRecycled?.Invoke(obj);
    }

    private Transform GetPoolParent(GameObject obj)
    {
        if (!_objectToPoolMap.TryGetValue(obj, out var poolName)) return transform;

        var config = poolConfigs.Find(c => c.poolName == poolName);
        return config?.poolParent ?? transform;
    }

    /// <summary>
    /// 从对象池获取对象
    /// </summary>
    public GameObject Get(string poolName, Vector3 position, Quaternion rotation)
    {
        if (!_pools.TryGetValue(poolName, out var pool))
        {
            Debug.LogError($"对象池 {poolName} 不存在");
            return null;
        }

        var obj = pool.Get();
        if (obj == null) return obj;

        obj.transform.localPosition = position;
        obj.transform.localRotation = rotation;
        obj.transform.localScale = Vector3.one;

        return obj;
    }

    /// <summary>
    /// 从对象池获取对象
    /// </summary>
    public GameObject Get(string poolName)
    {
        return Get(poolName, Vector3.zero, Quaternion.identity);
    }

    /// <summary>
    /// 归还对象到对象池
    /// </summary>
    public void Return(GameObject obj)
    {
        if (obj == null) return;

        var pooledObject = obj.GetComponent<PooledObject>();
        if (pooledObject != null && _pools.TryGetValue(pooledObject.PoolName, out var pool))
        {
            pool.Return(obj);
        }
        else
        {
            // 如果没有找到对应的池，直接销毁
            Destroy(obj);
        }
    }

    /// <summary>
    /// 获取对象池统计信息
    /// </summary>
    public void GetPoolStats(out Dictionary<string, (int active, int inactive)> stats)
    {
        stats = new Dictionary<string, (int, int)>();
        foreach (var kvp in _pools)
        {
            stats[kvp.Key] = (kvp.Value.CountActive, kvp.Value.CountInactive);
        }
    }

    protected override void OnDestroy()
    {
        base.OnDestroy();
        foreach (var pool in _pools.Values)
        {
            pool.Clear();
        }

        _pools.Clear();
        _objectToPoolMap.Clear();
    }
}

/// <summary>
/// 基础泛型对象池
/// </summary>
/// <typeparam name="T">对象类型</typeparam>
public class ObjectPool<T> : IPool<T> where T : class
{
    private readonly Stack<T> _pool;
    private readonly Func<T> _createFunc;
    private readonly Action<T> _onGet;
    private readonly Action<T> _onReturn;
    private readonly Action<T> _onDestroy;

    private int _maxSize;
    private int _activeCount;

    public int CountInactive => _pool.Count;
    public int CountActive => _activeCount;
    public int MaxSize => _maxSize;

    /// <summary>
    /// 构造函数
    /// </summary>
    /// <param name="createFunc">创建对象的函数</param>
    /// <param name="onGet">获取对象时的回调</param>
    /// <param name="onReturn">归还对象时的回调</param>
    /// <param name="onDestroy">销毁对象时的回调</param>
    /// <param name="initialSize">初始大小</param>
    /// <param name="maxSize">最大大小</param>
    public ObjectPool(
        Func<T> createFunc,
        Action<T> onGet = null,
        Action<T> onReturn = null,
        Action<T> onDestroy = null,
        int initialSize = 10,
        int maxSize = 100)
    {
        _createFunc = createFunc ?? throw new ArgumentNullException(nameof(createFunc));
        _onGet = onGet;
        _onReturn = onReturn;
        _onDestroy = onDestroy;
        _maxSize = maxSize;
        _activeCount = 0;
        _pool = new Stack<T>(initialSize);

        // 预创建对象
        for (var i = 0; i < initialSize; i++)
        {
            _pool.Push(createFunc());
        }
    }

    public T Get()
    {
        var obj = _pool.Count > 0 ? _pool.Pop() : _createFunc();
        _onGet?.Invoke(obj);
        _activeCount++;

        return obj;
    }

    public void Return(T obj)
    {
        if (obj == null)
        {
            throw new ArgumentNullException(nameof(obj));
        }

        _onReturn?.Invoke(obj);

        if (_pool.Count < _maxSize)
        {
            _pool.Push(obj);
        }
        else
        {
            _onDestroy?.Invoke(obj);
        }

        _activeCount = Mathf.Max(0, _activeCount - 1);
    }

    public void Clear()
    {
        while (_pool.Count > 0)
        {
            var obj = _pool.Pop();
            _onDestroy?.Invoke(obj);
        }

        _activeCount = 0;
    }

    public void Resize(int newMaxSize)
    {
        _maxSize = newMaxSize;

        // 如果新的大小小于当前池大小，移除多余对象
        while (_pool.Count > _maxSize)
        {
            var obj = _pool.Pop();
            _onDestroy?.Invoke(obj);
        }
    }
}

/// <summary>
/// 池对象组件，用于自动归还
/// </summary>
public class PooledObject : MonoBehaviour
{
    public string PoolName { get; set; }
}

/// <summary>
/// 对象池接口
/// </summary>
/// <typeparam name="T">对象类型</typeparam>
public interface IPool<T> where T : class
{
    T Get();
    void Return(T obj);
    void Clear();
    int CountInactive { get; }
    int CountActive { get; }
}
```

## 5. 服务层设计

暂无，待设计

## 6. 配置数据管理

### 6.1 ScriptableObject配置

```csharp
[CreateAssetMenu(fileName = "GlobalConfig", menuName = "Configs/GlobalConfig")]
public class GlobalConfig : ScriptableObject
{
    public float pipeMoveSpeed = 200f; // 管道移动速度
    public float spawnInterval = 2f; // 管道生成时间间隔(秒)
    public float spawnXPosition = 1100f; //管道生成位置的x坐标
    public float pipeTriggerOffsetX = 100f; // 上下两个管道间用来检测小鸟通过的检测器与管道的x轴上坐标插值
    public Vector2 pipeIntervalY = new(350f, 600f);// 上下两个管道间距的随机范围
    public Vector2 pipeCenterY = new(-150f, 150f); // 上下两个管道中心点在y轴上的随即范围
    public GameObject pipePrefab; // 管道预制体
    public GameObject pipeTriggerPrefab; // 管道触发器的预制体
}

```

这样的架构设计具有以下优势：

**高内聚低耦合**：各系统职责明确，通过事件通信

**易于扩展**：新增游戏模式只需实现策略接口

**易于测试**：依赖注入和接口隔离便于单元测试

**维护性好**：清晰的架构层次和设计模式应用

**性能优化**：对象池、事件系统减少GC压力
