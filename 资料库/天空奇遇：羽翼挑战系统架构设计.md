# 《天空奇遇：羽翼挑战》系统架构设计

## 1. 整体架构概览

采用**分层架构** + **组件模式**，核心设计模式：

1. **状态模式**：游戏状态管理

2. **观察者模式**：事件系统

3. **MVVM模式**：UI数据绑定

4. **策略模式**：游戏模式切换

5. **单例模式**：管理器类

6. **对象池模式**：性能优化

## 2. 核心系统架构

### 2.1 游戏状态机系统 (State Pattern)

```csharp
// 状态基类
public abstract class GameState
{
    public abstract void Enter();
    public abstract void Exit();
    public abstract void Update();
}

// 具体状态类
public class MenuState : GameState
{
    public override void Enter() { /*显示主菜单 */ }
    public override void Exit() { /* 隐藏主菜单 */ }
    public override void Update() { /* 处理菜单逻辑*/ }
}

public class PlayingState : GameState
{
    public override void Enter() { /*开始游戏 */ }
    public override void Exit() { /* 清理游戏 */ }
    public override void Update() { /* 游戏逻辑更新*/ }
}

public class PauseState : GameState { /*实现略 */ }
public class GameOverState : GameState { /* 实现略*/ }

// 状态管理器
public class GameStateMachine
{
    private Dictionary<Type, GameState> _states;
    private GameState_currentState;

    public void RegisterState<T>(T state) where T : GameState { }
    public void ChangeState<T>() where T : GameState { }
}
```

### 2.2 事件系统 (Observer Pattern)

```csharp
// 事件基类
public abstract class GameEvent { }

// 具体事件
public class BirdCollisionEvent : GameEvent
{
    public int RemainingLives { get; set; }
}

public class ScoreChangedEvent : GameEvent
{
    public int NewScore { get; set; }
}

// 事件管理器
public class EventManager
{
    private Dictionary<Type, List<Action<GameEvent>>> _listeners;

    public void AddListener<T>(Action<T> listener) where T : GameEvent { }
    public void RemoveListener<T>(Action<T> listener) where T : GameEvent { }
    public void TriggerEvent(GameEvent gameEvent) { }
}
```

### 2.3 游戏模式系统 (Strategy Pattern)

```csharp
// 游戏模式策略接口
public interface IGameModeStrategy
{
    void Initialize();
    void Start();
    void Update();
    void Cleanup();
    GameResult GetResult();
}

// 具体策略实现
public class InfiniteModeStrategy : IGameModeStrategy
{
    private PipeSpawner _pipeSpawner;
    private ScoreManager_scoreManager;

    public void Initialize() 
    { 
        _pipeSpawner.SetRandomMode(true);
    }
    
    public GameResult GetResult() 
    { 
        return new GameResult { Score = _scoreManager.CurrentScore };
    }
}

public class LevelModeStrategy : IGameModeStrategy
{
    private LevelData _currentLevel;
    private int_collisionCount;

    public void Initialize() 
    { 
        _pipeSpawner.LoadLevelData(_currentLevel);
    }
    
    public GameResult GetResult()
    {
        int stars = Math.Max(0, 3 - _collisionCount);
        return new LevelResult { 
            Stars = stars, 
            LevelCompleted = stars > 0 
        };
    }
}

public class ChallengeModeStrategy : IGameModeStrategy
{
    private string _seed;
    private ChallengeData_challengeData;

    public void Initialize() 
    { 
        _pipeSpawner.SetSeed(_seed);
    }
}
```

### 2.4 UI系统 (MVVM Pattern)

```csharp
// ViewModel基类
public abstract class ViewModel : MonoBehaviour
{
    protected readonly BindableProperty<string> _title = new();
    protected readonly BindableProperty<bool>_isVisible = new();

    public BindableProperty<string> Title => _title;
    public BindableProperty<bool> IsVisible => _isVisible;
}

// 游戏UI ViewModel
public class GameUIViewModel : ViewModel
{
    public BindableProperty<int> Score { get; } = new();
    public BindableProperty<int> Lives { get; } = new();
    public BindableProperty<float> Distance { get; } = new();

    public Command RetryCommand { get; } = new();
    public Command PauseCommand { get; } = new();
}

// 数据绑定系统
public class BindableProperty<T>
{
    private T _value;
    public event Action<T> OnValueChanged;

    public T Value
    {
        get => _value;
        set
        {
            if (!Equals(_value, value))
            {
                _value = value;
                OnValueChanged?.Invoke(value);
            }
        }
    }
}
```

## 3. 核心管理器类设计

### 3.1 游戏管理器 (Facade Pattern)

```csharp
public class GameManager : MonoBehaviour
{
    [SerializeField] private GameStateMachine _stateMachine;
    [SerializeField] private EventManager_eventManager;
    [SerializeField] private ModeManager _modeManager;
    [SerializeField] private UIManager_uiManager;

    private static GameManager _instance;
    public static GameManager Instance => _instance;
    
    private void Awake()
    {
        if (_instance == null)
        {
            _instance = this;
            DontDestroyOnLoad(gameObject);
            Initialize();
        }
        else
        {
            Destroy(gameObject);
        }
    }
    
    private void Initialize()
    {
        // 注册状态
        _stateMachine.RegisterState(new MenuState());
        _stateMachine.RegisterState(new PlayingState());
        
        // 注册事件监听
        _eventManager.AddListener<BirdCollisionEvent>(OnBirdCollision);
    }
    
    private void OnBirdCollision(BirdCollisionEvent e)
    {
        // 处理碰撞逻辑
    }
}
```

### 3.2 模式管理器

```csharp
public class ModeManager
{
    private IGameModeStrategy _currentStrategy;
    private Dictionary<GameMode, IGameModeStrategy>_strategies;

    public void RegisterStrategy(GameMode mode, IGameModeStrategy strategy)
    {
        _strategies[mode] = strategy;
    }
    
    public void SwitchMode(GameMode mode)
    {
        _currentStrategy?.Cleanup();
        _currentStrategy = _strategies[mode];
        _currentStrategy.Initialize();
    }
    
    public void Update()
    {
        _currentStrategy?.Update();
    }
}
```

### 3.3 数据管理层 (Repository Pattern)

```csharp
public interface IGameDataRepository
{
    PlayerData GetPlayerData();
    void SavePlayerData(PlayerData data);
    List<LevelData> GetLevels();
    ChallengeRecord GetChallengeRecord(string playerId);
}

public class LocalDataRepository : IGameDataRepository
{
    public PlayerData GetPlayerData()
    {
        // 从PlayerPrefs或本地文件读取
    }

    public void SavePlayerData(PlayerData data)
    {
        // 保存到PlayerPrefs或本地文件
    }
}

public class OnlineDataRepository : IGameDataRepository
{
    public async Task<ChallengeRecord> GetChallengeRecord(string playerId)
    {
        // 从服务器获取挑战记录
    }
}
```

## 4. 实体组件设计

### 4.1 小鸟控制器

```csharp
public class BirdController : MonoBehaviour
{
    [SerializeField] private Rigidbody2D _rigidbody;
    [SerializeField] private float_jumpForce = 5f;

    private BirdModel _model;
    private InputHandler _inputHandler;
    
    private void Awake()
    {
        _model = new BirdModel();
        _inputHandler = new TouchInputHandler(); // 可切换为键盘输入
    }
    
    private void Update()
    {
        if (_inputHandler.ShouldJump())
        {
            Jump();
        }
    }
    
    private void Jump()
    {
        _rigidbody.velocity = Vector2.zero;
        _rigidbody.AddForce(Vector2.up * _jumpForce, ForceMode2D.Impulse);
        EventManager.Instance.TriggerEvent(new BirdJumpEvent());
    }
    
    private void OnCollisionEnter2D(Collision2D collision)
    {
        _model.CollisionCount++;
        EventManager.Instance.TriggerEvent(new BirdCollisionEvent { 
            RemainingLives = _model.MaxLives - _model.CollisionCount 
        });
    }
}
```

### 4.2 管道生成器 (Object Pool + Builder Pattern)

```csharp
public class PipeSpawner : MonoBehaviour
{
    [SerializeField] private PipePool _pipePool;
    [SerializeField] private PipeConfiguration_config;

    private IPipeGenerationStrategy _generationStrategy;
    
    public void SetRandomMode(bool isRandom)
    {
        _generationStrategy = isRandom ? 
            new RandomPipeStrategy() : 
            new FixedPipeStrategy();
    }
    
    public void SetSeed(string seed)
    {
        Random.InitState(seed.GetHashCode());
    }
    
    public void LoadLevelData(LevelData levelData)
    {
        _generationStrategy = new LevelPipeStrategy(levelData);
    }
}

// 管道生成策略
public interface IPipeGenerationStrategy
{
    PipeData GetNextPipe();
    bool HasNextPipe();
}

public class RandomPipeStrategy : IPipeGenerationStrategy
{
    public PipeData GetNextPipe()
    {
        return new PipeData {
            Height = Random.Range(_minHeight,_maxHeight),
            GapSize = Random.Range(_minGap,_maxGap)
        };
    }
}
```

## 5. 服务层设计

### 5.1 排行榜服务

```csharp
public interface ILeaderboardService
{
    Task SubmitScore(int score, GameMode mode);
    Task<List<LeaderboardEntry>> GetTopScores(int count, GameMode mode);
    Task<LeaderboardEntry> GetPlayerRank(string playerId, GameMode mode);
}

public class UnityGamingService : ILeaderboardService
{
    public async Task SubmitScore(int score, GameMode mode)
    {
        // 调用UGS API
    }
}
```

### 5.2 联机服务

```csharp
public interface IOnlineService
{
    Task<MatchResult> FindMatch();
    Task SubmitChallengeResult(ChallengeResult result);
    Task<ChallengeData> GetChallengeData(string opponentId);
}

public class PhotonOnlineService : IOnlineService
{
    public async Task<MatchResult> FindMatch()
    {
        // Photon匹配逻辑
    }
}
```

## 6. 配置数据管理

### 6.1 ScriptableObject配置

```csharp
[CreateAssetMenu]
public class GameConfig : ScriptableObject
{
    [Header("小鸟设置")]
    public float BirdJumpForce = 5f;
    public float BirdGravityScale = 1f;

    [Header("管道设置")]
    public float PipeMoveSpeed = 2f;
    public float PipeSpawnInterval = 2f;
    
    [Header("游戏模式设置")]
    public InfiniteModeConfig InfiniteConfig;
    public LevelModeConfig LevelConfig;
    public ChallengeModeConfig ChallengeConfig;
}

[System.Serializable]
public class InfiniteModeConfig
{
    public float MinPipeHeight = 1f;
    public float MaxPipeHeight = 4f;
}
```

这样的架构设计具有以下优势：

**高内聚低耦合**：各系统职责明确，通过事件通信

**易于扩展**：新增游戏模式只需实现策略接口

**易于测试**：依赖注入和接口隔离便于单元测试

**维护性好**：清晰的架构层次和设计模式应用

**性能优化**：对象池、事件系统减少GC压力
